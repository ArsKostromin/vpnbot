# payments/views.py
import hashlib
from decimal import Decimal, InvalidOperation

from django.conf import settings
from django.http import HttpResponse
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.views import APIView

from user.models import VPNUser
from payments.models import Payment
from payments.cryptobot import generate_crypto_payment_link
from payments.utils import apply_payment
from payments.services import (
    generate_unique_inv_id,
    generate_robokassa_payment_link,
    verify_robokassa_signature
)
import logging

logger = logging.getLogger(__name__)


@api_view(["POST"])
def create_payment(request):
    """
    –°–æ–∑–¥–∞–Ω–∏–µ Robokassa-–ø–ª–∞—Ç–µ–∂–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    """
    telegram_id = request.data.get("telegram_id")
    amount = request.data.get("amount")

    if not telegram_id:
        return Response({"error": "telegram_id is required"}, status=status.HTTP_400_BAD_REQUEST)

    try:
        amount = int(amount)
    except (ValueError, TypeError):
        return Response({"error": "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞."}, status=status.HTTP_400_BAD_REQUEST)

    user = VPNUser.objects.get(telegram_id=telegram_id)

    payment = Payment.objects.create(
        user=user,
        inv_id=generate_unique_inv_id(),
        amount=Decimal(amount),
        status=Payment.Status.PENDING,
        currency='–†—É–±–ª–∏'
    )

    payment_link = generate_robokassa_payment_link(payment)
    return Response({"payment_url": payment_link})


@api_view(["GET", "POST"])
def payment_result(request):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ callback'–∞ –æ—Ç Robokassa –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã.
    """
    out_sum = request.data.get("OutSum")
    inv_id = request.data.get("InvId")
    received_signature = request.data.get("SignatureValue", "").strip()

    if not out_sum or not inv_id or not received_signature:
        return Response({"error": "Missing required fields."}, status=status.HTTP_400_BAD_REQUEST)

    if not verify_robokassa_signature(out_sum, inv_id, received_signature):
        return Response({"error": "Invalid signature."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        payment = Payment.objects.get(inv_id=inv_id)
    except Payment.DoesNotExist:
        return Response({"error": "Payment not found."}, status=status.HTTP_404_NOT_FOUND)

    if payment.status == Payment.Status.SUCCESS:
        return Response(f"OK{inv_id}")

    apply_payment(payment.user, Decimal(out_sum))
    payment.status = Payment.Status.SUCCESS
    payment.save()

    return Response(f"OK{inv_id}")


@api_view(["GET", "POST"])
def success_payment(request):
    """–°—Ç—Ä–∞–Ω–∏—Ü–∞ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–π –æ–ø–ª–∞—Ç–µ."""
    return HttpResponse("<h1>–û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ! üéâ</h1>")


@api_view(["GET", "POST"])
def fail_payment(request):
    """–°—Ç—Ä–∞–Ω–∏—Ü–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ –æ–ø–ª–∞—Ç—ã –∏–ª–∏ –æ—Ç–º–µ–Ω–µ."""
    return HttpResponse("<h1>–û–ø–ª–∞—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞ –∏–ª–∏ –æ—à–∏–±–∫–∞ –ø–ª–∞—Ç–µ–∂–∞.</h1>")


class CreateCryptoPaymentAPIView(APIView):
    """
    –°–æ–∑–¥–∞–Ω–∏–µ –∫—Ä–∏–ø—Ç–æ–ø–ª–∞—Ç–µ–∂–∞ —á–µ—Ä–µ–∑ Telegram CryptoBot.
    """
    def post(self, request):
        telegram_id = request.data.get("telegram_id")
        amount_rub = request.data.get("amount")
        asset = request.data.get("asset", "TON")

        if not amount_rub:
            return Response({"error": "–ü–æ–ª–µ 'amount' –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ"}, status=400)

        try:
            amount_rub = Decimal(amount_rub)
            if amount_rub <= 0:
                raise ValueError
        except (InvalidOperation, ValueError):
            return Response({"error": "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç 'amount'"}, status=400)

        user = VPNUser.objects.filter(telegram_id=telegram_id).first()
        if not user:
            return Response({"error": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"}, status=404)

        payment = Payment.objects.create(
            user=user,
            inv_id=generate_unique_inv_id(),
            amount=amount_rub,
            status=Payment.Status.PENDING,
            currency=asset,
        )

        pay_url = generate_crypto_payment_link(payment, asset, amount_rub)
        return Response({"payment_url": pay_url, "inv_id": payment.inv_id})


@api_view(["POST"])
def crypto_webhook(request):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ webhook-–∞ –æ—Ç CryptoBot –æ–± —É—Å–ø–µ—à–Ω–æ–π –æ–ø–ª–∞—Ç–µ.
    """
    event = request.data
    logger.info(f"[Webhook] –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–±—ã—Ç–∏–µ: {event}")

    if event.get("type") != "invoice_paid":
        logger.warning("[Webhook] –ù–µ —è–≤–ª—è–µ—Ç—Å—è —Å–æ–±—ã—Ç–∏–µ–º –æ–ø–ª–∞—Ç—ã")
        return Response({"message": "Not a payment event"}, status=status.HTTP_200_OK)

    payload = event.get("payload")
    if not payload:
        logger.error("[Webhook] Payload –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç")
        return Response({"error": "Missing payload"}, status=status.HTTP_400_BAD_REQUEST)

    try:
        inv_id = int(payload)
    except ValueError:
        logger.error(f"[Webhook] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç payload: {payload}")
        return Response({"error": "Invalid payload format"}, status=status.HTTP_400_BAD_REQUEST)

    try:
        payment = Payment.objects.get(inv_id=inv_id)
    except Payment.DoesNotExist:
        logger.error(f"[Webhook] –ü–ª–∞—Ç—ë–∂ —Å inv_id={inv_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return Response({"error": "Payment not found"}, status=status.HTTP_404_NOT_FOUND)

    if payment.status == Payment.Status.SUCCESS:
        logger.info(f"[Webhook] –ü–ª–∞—Ç—ë–∂ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω: inv_id={inv_id}")
        return Response({"message": "Already processed"}, status=status.HTTP_200_OK)

    try:
        apply_payment(payment.user, payment.amount)
        payment.status = Payment.Status.SUCCESS
        payment.save()
        logger.info(f"[Webhook] –ü–ª–∞—Ç—ë–∂ —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω: inv_id={inv_id}")
        return Response({"message": "Payment processed"}, status=status.HTTP_200_OK)
    except Exception as e:
        logger.exception(f"[Webhook] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –ø–ª–∞—Ç–µ–∂–∞ inv_id={inv_id}: {e}")
        return Response({"error": "Internal error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



class StarPaymentAPIView(APIView):
    """
    –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–µ –∑–≤—ë–∑–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.
    """
    def post(self, request):
        user_id = request.data.get("user_id")
        amount = float(request.data.get("amount"))

        user = VPNUser.objects.get(telegram_id=user_id)

        payment = Payment.objects.create(
            user=user,
            inv_id=generate_unique_inv_id(),
            amount=amount,
            status=Payment.Status.SUCCESS,
            currency='Tg stars'
        )

        apply_payment(user, Decimal(amount))

        return Response({
            "message": "OK",
            "amount": amount,
        }, status=status.HTTP_201_CREATED)
